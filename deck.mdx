export { dark as theme } from 'mdx-deck/themes';

# :fire: Let's get some Context :fire:

Anushree Subramani

@imAnushree

---

import { Notes } from 'mdx-deck';

# :wave:

<Notes>Alright, thats enough about me. Now, lets get this party started</Notes>

---

Consider this:

```jsx
<Page user={user} avatarSize={avatarSize} />
// ... which renders ...
<PageLayout user={user} avatarSize={avatarSize} />
// ... which renders ...
<NavigationBar user={user} avatarSize={avatarSize} />
// ... which renders ...
<Link href={user.permalink}>
  <Avatar user={user} size={avatarSize} />
</Link>
```

<Notes>
  Lets analyse this component tree together: Good: - Components split up
  logically with all the props getting passed down explicitly - Can trace the
  flow of data for debugging - This is the accepted react way of doing things in
  most cases Bad: - Intermediary components have to act as prop messengers -
  Refactoring is hard when nesting gets too deep
</Notes>

---

### Problems :cold_sweat:

- Intermediary components have to act as prop messengers
- Refactoring is hard when nesting gets too deep

Commonly referred as "Prop drilling"
(Shout out to Kent Dodds :tada:)

---

## Solution ? :thinking:

---

## Component composition to the rescue !

<Notes> (if you all thought i was gonna say context, hold your horses) </Notes>

---

### Component Composition

```jsx
function Page(props) {
  const user = props.user;
  const userLink = (
    <Link href={user.permalink}>
      <Avatar user={user} size={props.avatarSize} />
    </Link>
  );
  return <PageLayout userLink={userLink} />;
}
// Now we have
<Page user={user} avatarSize={avatarSize} />
// ... which renders ...
<PageLayout userLink={...} />
// ... which renders ...
<NavigationBar userLink={...} />
// ... which renders ...
{props.userLink}
```

<Notes>
  - We are passing the whole component down as prop here. - Refactoring the
  nested component is easy now because we just make changes at the parent level.
  Don't have to worry about changing the props in all the components But,
  downside is that it increases the complexity of the parent component.
</Notes>

---

# Multiple Children - Slots

```jsx
function Page(props) {
  const user = props.user;
  const content = <Feed user={user} />;
  const topBar = (
    <NavigationBar>
      <Link href={user.permalink}>
        <Avatar user={user} size={props.avatarSize} />
      </Link>
    </NavigationBar>
  );
  return <PageLayout topBar={topBar} content={content} />;
}
```

---

At this point you must be thinking "umm.. I was told this is a talk on react
Context" :)
Some cute emoji

<Notes>
  Well, We may have solved the prop drilling problem for this particular
  subtree(local data). But what if we need to share data between different parts
  of component tree with different nesting levels? Broadcast data?
</Notes>

---

Context API

<Notes>What is Context API?</Notes>

---

# What is Context API?

<blockquote>
  Context provides a way to pass "global" data down a component subtree without
  (explicitly)passing props down 
</blockquote>
Ex: currentUser, theme, locale etc

<Notes>
  Values like currentUser, theme, locale etc are required by multiple components
  throughout the app and context provides a way to share values like these
  between different components without having to explicitly pass down props
</Notes>

---

# Evolution of Context API

```
Legacy API  ->  New stable API(16.3) -> React 16.6  -> Hooks(16.8)
                (Provider, Consumer)    (contextType)  (useContext)

```

---

# Syntax of Context API

createContext

```jsx
export const ThemeContext = React.createContext({ theme: 'dark' });
```

Provider

```jsx
<ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
```

Consumer
contextType(class component)

```jsx
class Layout extends React.Component {
  static contextType = ThemeContext;
  render() {
    let value = this.context;
    /* render something based on the value of ThemeContext */
  }
}
```

useContext(functional component)

```jsx
function ThemeButton() {
  const context = React.useContext(ThemeContext);
  const { theme, toggleTheme } = context;
  return (...);
}
```

Example:

theme-context.js

```jsx
export const ThemeContext = React.createContext({
  theme: themes.dark,
  toggleTheme: () => {}
});
```

app.js

```jsx
import React from 'react';
import { ThemeContext } from './theme-context.js';
import { themes } from './themes.js';

class App extends React.Component {
  toggleTheme = () => { ... }

  render() {
    const value = React.useMemo(() => {
    return {
      theme: themes.light,
      toggleTheme: this.toggleTheme
    }
  }, [theme])
    return (
      <ThemeContext.Provider
        value={value}
      >
        <Content />
      </ThemeContext.Provider>
    );
  }
}
```

content.js

```jsx
import React from 'react';
import {ThemeButton} from './theme-button.js';
function Content() {
  return(
    <div><ThemeButton></div>
  )
}
```

theme-button.js

```jsx
import React from 'react';
import { ThemeContext } from './theme-context.js';

function ThemeButton() {
  const context = React.useContext(ThemeContext);
  const { theme, toggleTheme } = context;
  return (
    <button onClick={toggleTheme} style={{ backgroundColor: theme.background }}>
      Toggle Theme
    </button>
  );
}
```

---

## Caveat - Performance Issue with value

```jsx
<Context.Provider value={{ something: 'something' }}>
  <Toolbar />
</Context.Provider>
```

<Notes>Unnecessary rerender </Notes>

---

Prop drilling problem solved by Context ! Yaayyy! :tada:

---

## Does Context replace redux: The burning question

Self introspection time:
Why do I use redux in my app?
ReactRedux has connect() -> solves prop drilling
time-travel debugging
Middleware
For Redux Devtools
List goes on

---

If your answer was connect(), then absolutely Context replaces redux.
But if you want any of the other features, then no
Refer Mark Erikson's blog for details

---

Summary:
When to reach for what solution: Composition vs Context
Weigh the pros and cons for everything - not just while selecting libraries/tools. We need to make decisions about patterns and APIs as well and choose the best fit
Choosing a library or framework is just one part of the process
Ultimately your app performance, code quality, maintainability etc will depend on the coding standards, patterns and API you decide to use along the way
Cliche Toolkit example - pick the right one for the job
How to decide what is right tool?
Discovery
Interact with other developers in the community(twitter, reddit etc)
Read OSS code
Do a POC, ask for feedback from your team and the community
Development
Write tests, run benchmarks and write refactorable flexible code wherever possible

---

Thank you
@imAnushree

TODO:
Feedback Link
Footer in all slides with ref links
JSMonthly May 2019 @imAnushree
Add more ref links

---

References

https://www.youtube.com/watch?v=PaE-TfTY8TY
https://kentcdodds.com/blog/prop-drilling

https://blog.isquaredsoftware.com/2018/03/redux-not-dead-yet/
